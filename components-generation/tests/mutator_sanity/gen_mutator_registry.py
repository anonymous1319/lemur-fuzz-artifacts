#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import re
from pathlib import Path

DEF_NAME_REGEX = r'^(add_|mutate_|delete_|repeat_)'

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--mutators", required=True, help="path to mutators .c file")
    ap.add_argument("--out", required=True, help="output mutator_registry.c path")
    ap.add_argument("--pkt-type", required=True, help="packet type name, e.g. ftp_packet_t")
    ap.add_argument("--name-regex", default=DEF_NAME_REGEX, help="regex for mutator function names")
    ap.add_argument("--exclude-regex", default="", help="regex to exclude names (default: exclude none)")
    args = ap.parse_args()

    mut_path = Path(args.mutators)
    if not mut_path.exists():
        raise SystemExit(f"[!] mutators file not found: {mut_path}")

    src = mut_path.read_text(errors="ignore")

    func_def_re = re.compile(
        r'(?ms)^[ \t]*(?:static[ \t]+)?(?:inline[ \t]+)?(?:void|int)[ \t]+'
        r'([A-Za-z_][A-Za-z0-9_]*)[ \t]*\(([^)]*)\)[ \t]*\{'
    )


    name_re = re.compile(args.name_regex)
    excl_re = re.compile(args.exclude_regex) if args.exclude_regex else None

    pkt_type = args.pkt_type

    def ok_signature(arg_str: str) -> bool:
        parts = [p.strip() for p in arg_str.split(",") if p.strip()]
        if len(parts) != 2:
            return False

        p0 = re.sub(r"\s+", " ", parts[0])
        p1 = re.sub(r"\s+", " ", parts[1])

        if not re.search(rf'\b(?:const\s+)?{re.escape(pkt_type)}\s*\*\s*[A-Za-z_]\w*\b', p0):
            return False

        if not re.search(r'\b(?:int|u32|uint32_t|size_t)\b', p1):
            return False

        return True

    names = []
    for m in func_def_re.finditer(src):
        fn = m.group(1)
        arg_str = m.group(2)

        if not name_re.search(fn):
            continue
        if excl_re and excl_re.search(fn):
            continue
        if not ok_signature(arg_str):
            continue

        names.append(fn)


    seen = set()
    uniq = []
    for n in names:
        if n not in seen:
            seen.add(n)
            uniq.append(n)

    if not uniq:
        raise SystemExit(
            "[!] No mutator functions matched.\n"
            "    Tips:\n"
            "      - check --name-regex\n"
            "      - ensure mutators have signature: void f(pkt_type *pkts, int/u32 num)\n"
            "      - check --pkt-type matches your packets.h typedef\n"
        )

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    rel_include = os.path.relpath(mut_path.resolve(), out_path.parent.resolve())

    body = []
    body.append("/* Auto-generated by tests/mutator_sanity/gen_mutator_registry.py. DO NOT EDIT. */\n")
    body.append("#include <stddef.h>\n")
    body.append('#include "mutator_registry.h"\n')
    body.append('#include "adapter.h"\n\n')
    body.append("/* Include mutator implementation so even static mutators are visible here. */\n")
    body.append(f'#include "{rel_include}"\n\n')

    body.append("const mutator_desc_t g_mutators[] = {\n")
    for fn in uniq:
        body.append(f'  {{"{fn}", (mutator_fn_t){fn}}},\n')
    body.append("};\n\n")
    body.append("const size_t g_mutators_count = sizeof(g_mutators) / sizeof(g_mutators[0]);\n")

    out_path.write_text("".join(body))
    print(f"[+] Generated: {out_path} ({len(uniq)} mutators)")
    for fn in uniq[:10]:
        print("    -", fn)
    if len(uniq) > 10:
        print(f"    ... ({len(uniq)-10} more)")

if __name__ == "__main__":
    main()
