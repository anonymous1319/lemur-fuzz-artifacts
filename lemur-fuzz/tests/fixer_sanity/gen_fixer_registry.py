#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import re
from pathlib import Path

DEF_NAME_REGEX = r'^(fix_|repair_|ensure_)'

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--fixers", required=True, help="path to fixers .c file")
    ap.add_argument("--out", required=True, help="output fixer_registry.c path")
    ap.add_argument("--pkt-type", required=True, help="packet type name, e.g. dtls_packet_t")
    ap.add_argument("--name-regex", default=DEF_NAME_REGEX)
    args = ap.parse_args()

    fix_path = Path(args.fixers)
    if not fix_path.exists():
        raise SystemExit(f"[!] fixers file not found: {fix_path}")
    src = fix_path.read_text(errors="ignore")

    func_def_re = re.compile(
        r'(?ms)^[ \t]*(?:static[ \t]+)?(?:inline[ \t]+)?(int|void)[ \t]+'
        r'([A-Za-z_][A-Za-z0-9_]*)[ \t]*\(([^)]*)\)[ \t]*\{'
    )

    name_re = re.compile(args.name_regex)
    pkt_type = args.pkt_type

    def ok_sig(arg_str: str) -> bool:
        parts = [p.strip() for p in arg_str.split(",") if p.strip()]
        if len(parts) != 2:
            return False
        if not re.search(rf'\b(?:const\s+)?{re.escape(pkt_type)}\s*\*\s*[A-Za-z_]\w*\b', parts[0]):
            return False
        if not re.search(r'\b(?:int|u32|uint32_t|size_t)\b', parts[1]):
            return False
        return True

    funcs = []
    for m in func_def_re.finditer(src):
        rett = m.group(1)
        fn = m.group(2)
        args_str = m.group(3)
        if not name_re.search(fn):
            continue
        if not ok_sig(args_str):
            continue
        funcs.append((rett, fn))

    
    seen = set()
    uniq = []
    for rett, fn in funcs:
        if fn not in seen:
            seen.add(fn)
            uniq.append((rett, fn))

    if not uniq:
        raise SystemExit("[!] No fixer functions matched. Check name regex and signature.")

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    rel_include = os.path.relpath(fix_path.resolve(), out_path.parent.resolve())

    body = []
    body.append("/* Auto-generated by tests/fixer_sanity/gen_fixer_registry.py. DO NOT EDIT. */\n")
    body.append("#include <stddef.h>\n")
    body.append('#include "fixer_registry.h"\n')
    body.append('#include "adapter.h"\n\n')
    body.append("/* Include implementation so even static fixers are visible. */\n")
    body.append(f'#include "{rel_include}"\n\n')

    # wrappers for void fixers
    for rett, fn in uniq:
        if rett == "void":
            body.append(f"static int __wrap_{fn}(proto_packet_t *pkts, int num) {{ {fn}(pkts, num); return 0; }}\n")
    body.append("\n")

    body.append("const fixer_desc_t g_fixers[] = {\n")
    for rett, fn in uniq:
        target = f"__wrap_{fn}" if rett == "void" else fn
        body.append(f'  {{"{fn}", (fixer_fn_t){target}}},\n')
    body.append("};\n\n")
    body.append("const size_t g_fixers_count = sizeof(g_fixers) / sizeof(g_fixers[0]);\n")

    out_path.write_text("".join(body))
    print(f"[+] Generated: {out_path} ({len(uniq)} fixers)")

if __name__ == "__main__":
    main()
